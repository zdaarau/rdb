---
editor_options:
  chunk_output_type: console
---

# NOTES

The C2D Database offers a [privately documented](https://github.com/ccmdesign/c2d-app/blob/master/docs/services.md) API available under `services.c2d.ch` with
the following "endpoints":

-   `referendums`: get referendum data

    Data on individual referendums can be retrieved under `referendums/ID` where `ID` stands for the referendum's unique identifier `oid` (which corresponds to
    the column `id` in the data returned by the `referendums()` function of this package).

    It supports the following URL parameters:

    -   `mode`: the operation mode; one of `stream`, `count` or `search`
    -   `term` the search term used for `mode=search`; note that only the `title$en` field will be searched
    -   `format`: the data format to be returned when `mode=stream`; one of `json` or `csv`
    -   `filter`: a valid [JSON query filter document](https://docs.mongodb.com/v4.2/core/document/#query-filter-documents) to customize queries in the
        underlying mongoDB collection; needs to be Base64-encoded; there are various [query operators](https://docs.mongodb.com/v4.2/reference/operator/query/)
        available to build complex queries

-   `referendums/stats`: get the number of referendums

    It accepts the following URL parameter:

    -   `filter`: a valid [JSON query filter document](https://docs.mongodb.com/v4.2/core/document/#query-filter-documents) to customize queries in the
        underlying mongoDB collection; needs to be Base64-encoded; there are various [query operators](https://docs.mongodb.com/v4.2/reference/operator/query/)
        available to build complex queries

-   `states`: get the first 10 sub-national states that match the query

    It accepts the following URL parameters to customize the query:

    -   `country`: limits the results to a specific country code
    -   `term`: limits the result to states matching this search term

-   `health`: check API status

# INTERNAL

## Avoid `R CMD check` notes about undefined global objects used in magrittr pipes

Cf. <https://github.com/tidyverse/magrittr/issues/29#issuecomment-74313262>

```{r}
utils::globalVariables(names = c(".",
                                 "items"))
```

## Package load/unload

```{r}
.onLoad <- function(libname, pkgname) {
  pkgpins::clear(pkg = pkgname,
                 max_age = getOption("c2d.max_cache_lifespan",
                                     default = "30 days"))
}

.onUnload <- function(libpath) {
  pkgpins::deregister(pkg = pkg)
}
```

## Constants

```{r}
pkg <- utils::packageName()
```

## Functions

### Get httr config

Since the C2D API server doesn't provide the [intermediate *R3*
certificate](https://crt.sh/?q=+730c1bdcd85f57ce5dc0bba733e5f1ba5a925b2a771d640a26f7a454224dad3b) (issued by Let's Encrypt) and [curl doesn't support *Authority
Information Access* yet](https://github.com/curl/curl/issues/2793) to automatically discover it, we have to manually specify it. Thus, the certificate is
shipped with this package (found under `certs/3479778542.crt`).

The issue has been [reported](https://github.com/ccmdesign/c2d-app/issues/10) to the server operator.

```{r}
httr_config <- function() {
  
  httr::config(cainfo = system.file("certs", "3479778542.crt",
                                    package = pkg,
                                    mustWork = TRUE))
}
```

# Check API health

```{r}
#' Test C2D API availability
#'
#' Checks if the C2D API server is online and operational.
#'
#' @param quiet Whether to suppress printing a warning in case the API is unavailable.
#'
#' @return A logical scalar.
#' @export
is_online <- function(quiet = FALSE) {
  
  result <- FALSE
  response <- rlang::with_handlers(.expr = httr::RETRY(verb = "GET",
                                                       url = "https://services.c2d.ch/health",
                                                       config = httr_config(),
                                                       times = 5L),
                                   error = ~ paste0("Error: ", .x$message))
  
  if (class(response) == "response") {
    
    response %<>% httr::content(as = "parsed",
                                encoding = "UTF-8")
    
    if (response == "OK") {
      result <- TRUE
      
    } else if (checkmate::assert_flag(quiet)) {
      warning(glue::glue("C2D API server responded with '{response}'"),
              call. = FALSE,
              immediate. = TRUE)
    }
  }
  
  result
}
```

# Referendums

## Get data

TODO:

-   [ ] Implement getting partial results as soon as [internal issue \#11](https://github.com/ccmdesign/c2d-app/issues/11) is resolved.

NOTES:

-   The following values are used to denote empty values:

    -   `-1L` in integer fields (means "information not available or nonexistent")
    -   `-2L` in integer fields ([means "information not given"](https://github.com/ccmdesign/c2d-app/issues/13#issuecomment-802466615))
    -   `""` in character fields
    -   (Named) `list()` in array fields

-   The returned JSON data has between 22 and 26 fields. Fields that are not always present include:

    -   `archive`
    -   `canton`
    -   `municipality`
    -   `number`

-   The files listed in the `files` field can be retrieved by feeding `files.object_key` to the C2D API's `s3_objects/` endpoint, e.g.:

    ``` {.http}
    GET https://services.c2d.ch/s3_objects/referendum_5f859fafd1291cc3961f1bc2_0002.pdf
    ```

```{r}
#' Get referendum data
#'
#' Downloads the complete data about all referendums covered by the C2D Database.
#'
#' Currently, this function only allows to download the C2D referendums database in its entirety.
#'
#' @param use_cache `r pkgsnip::param_label("use_cache")`
#' @param cache_lifespan `r pkgsnip::param_label("cache_lifespan")`
#' @param incl_drafts Whether or not to include referendum entries with _draft_ status in the returned data.
#'
#' @return `r pkgsnip::return_label("data")`
#' @export
referendums <- function(use_cache = TRUE,
                        cache_lifespan = "1 week",
                        incl_drafts = FALSE) {
  
  pkgpins::with_cache(.fn = ~ {
    
    # retrieve data
    data <-
      httr::RETRY(verb = "GET",
                  url = "https://services.c2d.ch/referendums",
                  query = list(mode = "stream",
                               format = "json"),
                  config = httr_config(),
                  times = 5L) %>%
      httr::content(as = "parsed") %$%
      items %>%
      # wrap all array fields in another list level for subsequent conversion to tibble
      purrr::map(.f = ~ .x %>% purrr::modify_if(.p = ~ length(.x) != 1L,
                                                .f = ~ list(.x))) %>%
      # convert to tibble
      dplyr::bind_rows()
    
    # check integrity
    ## ensure there's always exactly *one* `oid` per row
    ids <- data$`_id` %>% purrr::map(length)
    
    if (length(unique(names(ids))) != 1L ||
        !"$oid" %in% unique(names(ids)) ||
        any(purrr::flatten_int(unique(ids))) != 1L) {
      
      rlang::abort(cli::format_error("Unexpected ID fields detected. Please debug."))
    }
    
    ## ensure `oid`s are unique
    if (data$`_id` %>%
        purrr::flatten_chr() %>%
        unique() %>%
        length() %>%
        magrittr::equals(nrow(data)) %>%
        magrittr::not()) {
      
      rlang::abort(cli::format_error("Duplicated {.var oid}s detected. Please debug."))
    }
    
    ## ensure `country_codes`s are valid
    invalid_country_codes <- data$country_code[!(data$country_code %in% countrycode::codelist$iso2c)]
    
    if (length(invalid_country_codes)) {
      rlang::abort(cli::format_error("Unknown {.var country_code}s detected. Please debug."))
    }
    
    # tidy data
    data %<>%
      # unnest `context`, `categories` and `title` (no technical need to be nested)
      tidyr::unnest_wider(col = context) %>%
      tidyr::unnest_wider(col = categories) %>%
      tidyr::unnest_wider(col = title,
                          names_sep = "_") %>%
      # rename variables
      dplyr::rename(created_datetime = created_on,
                    has_urgent_legal_basis = legal_act_type,
                    id = `_id`,
                    is_binding = vote_result_status,
                    is_counter_proposal = counter_proposal,
                    is_draft = draft,
                    legal_basis_type = official_status,
                    object_author = author_of_the_vote_object,
                    object_legal_level = hierarchy_of_the_legal_norm,
                    object_type = vote_object,
                    subnational_entity = canton,
                    trigger_actor = vote_trigger_actor,
                    trigger_state_level = vote_trigger_state_level,
                    trigger_threshold = vote_trigger_number,
                    trigger_time_limit = vote_trigger_time,
                    trigger_type = vote_trigger,
                    type = institution) %>%
      # recode variables
      dplyr::mutate(
        # flatten unnecessarily convoluted list columns
        dplyr::across(c(id,
                        action,
                        excluded_topics,
                        special_topics,
                        tags),
                      ~ .x %>% purrr::map(unlist)),
        # replace empty lists with `NULL` in list columns
        dplyr::across(where(is.list),
                      ~ dplyr::case_when(.x %>% purrr::map_lgl(~ length(.x) == 0L) ~ list(NULL),
                                         TRUE ~ .x)),
        # use explicit NA values
        dplyr::across(where(is.integer),
                      ~ dplyr::if_else(.x %in% c(-1L, -2L), NA_integer_, .x)),
        dplyr::across(where(is.character),
                      ~ dplyr::if_else(.x == "", NA_character_, .x)),
        # convert values to all-lowercase
        dplyr::across(c(legal_basis_type,
                        level,
                        object_author,
                        object_legal_level,
                        object_type,
                        result,
                        trigger_actor,
                        trigger_state_level,
                        trigger_type,
                        type),
                      stringr::str_to_lower),
        
        # specific recodings
        ## binary (dummies)
        is_binding = dplyr::case_when(is_binding == "Binding" ~ TRUE,
                                      is_binding == "Non-binding" ~ FALSE,
                                      TRUE ~ NA),
        is_counter_proposal = dplyr::case_when(is_counter_proposal == "Yes" ~ TRUE,
                                               is_counter_proposal == "No" ~ FALSE,
                                               TRUE ~ NA),
        has_urgent_legal_basis = dplyr::case_when(has_urgent_legal_basis == "Urgent" ~ TRUE,
                                                  has_urgent_legal_basis == "Normal" ~ FALSE,
                                                  TRUE ~ NA),
        ## nominal
        id = purrr::flatten_chr(id),
        level = stringr::str_replace(string = level,
                                     pattern = "sub-national",
                                     replacement = "subnational"),
        type = type %>% dplyr::recode("citizen assembly" = "citizens' assembly",
                                      "not provided" = NA_character_),
        trigger_actor = trigger_actor %>% dplyr::recode(institution = "other institution"),
        object_type = stringr::str_replace_all(string = object_type,
                                               pattern = c("ausformulierter vorschlag" = "formulated proposal",
                                                           "allg. anregung" = "general proposal")),
        ## ordinal
        ## interval
        created_datetime = purrr::flatten_dbl(created_datetime) %>% magrittr::divide_by(1000L) %>% lubridate::as_datetime()
      ) %>%
      # reorder columns
      dplyr::relocate(id,
                      is_draft,
                      country_code,
                      country_name,
                      subnational_entity,
                      municipality,
                      level,
                      type,
                      date,
                      created_datetime,
                      starts_with("title_"),
                      total_electorate,
                      citizens_abroad,
                      votes_yes,
                      votes_no,
                      votes_empty,
                      votes_invalid,
                      votes_per_canton,
                      result,
                      committee_name,
                      number, # TODO: Find out what this is!
                      object_type,
                      object_author,
                      object_legal_level,
                      legal_basis_type,
                      has_urgent_legal_basis,
                      degree_of_revision,
                      is_binding,
                      is_counter_proposal,
                      vote_venue,
                      starts_with("trigger_"),
                      turnout_quorum,
                      decision_quorum,
                      referendum_text_options,
                      institutional_precondition,
                      institutional_precondition_decision,
                      institutional_precondition_decision_actor,
                      action,
                      special_topics,
                      excluded_topics,
                      national_council_yes,
                      national_council_no,
                      national_council_abstentions,
                      states_council_yes,
                      states_council_no,
                      states_council_abstentions,
                      recommendation,
                      states_yes,
                      states_no,
                      remarks,
                      tags,
                      files,
                      archive) %>%
      purrr::when(incl_drafts ~ .,
                  ~ dplyr::filter(.data = ., !is_draft))
  },
  .use_cache = use_cache,
  .cache_lifespan = cache_lifespan,
  .pkg = pkg)
}
```

## Search

Currently, the C2D API [only supports searching in the English referendum
title](https://github.com/ccmdesign/c2d-app/blob/master/docs/services.md#3-referendum-routes).

```{r}
#' Search in English referendum titles
#'
#' Allows to use the C2D API's primitive search functionality. The search is not case-sensitive and no [fuzzy
#' search](https://en.wikipedia.org/wiki/Approximate_string_matching) is performed (i.e. only exact matches are returned).
#'
#' Note that this function is probably not of much use since it doesn't return any additional information about the matched referendums but only the English
#' titles.
#'
#' @param term The Search term. A character scalar.
#'
#' @return A character vector of English referendum titles matching the search `term`.
#' @export
#'
#' @examples
#' search_referendums("freedom")
search_referendums <- function(term) {
  
  httr::RETRY(verb = "GET",
              url = "https://services.c2d.ch/referendums",
              query = list(mode = "search",
                           term = checkmate::assert_string(term)),
              config = httr_config(),
              times = 5L) %>%
    httr::content(as = "parsed") %$%
    items %>%
    purrr::flatten_chr() 
}
```

## Download file attachment

```{r}
#' Download file attachment
#'
#' @param s3_object_key The key uniquely identifying the file in the C2D [Amazon S3 bucket](https://en.wikipedia.org/wiki/Amazon_S3#Design). A character scalar.
#' @param path The path where the downloaded file is written to. If a directory, the original filename returned by the C2D services API will be used.
#'
#' @return A [response object][httr::response], invisibly.
#' @export
#'
#' @examples
#' library(magrittr)
#'
#' \dontrun{
#' # get all file object keys...
#' c2d::referendums() %$%
#'   files %>%
#'   purrr::map_depth(2L, purrr::pluck, "object_key") %>%
#'   purrr::flatten() %>%
#'   purrr::flatten_chr() %>%
#'   # ...select first one...
#'   dplyr::first() %>%
#'   # ...and download the corresponding file to the current working dir
#'   c2d::download_file_attachment()}
download_file_attachment <- function(s3_object_key,
                                     path = ".") {
  if (fs::dir_exists(path)) {
    checkmate::assert_directory(path,
                                access = "rw")
    use_original_filename <- TRUE
  } else {
    checkmate::assert_path_for_output(path,
                                      overwrite = TRUE)
    use_original_filename <- FALSE
  }
  
  temp_path <- fs::file_temp()
  
  response <- httr::RETRY(verb = "GET",
                          url = paste0("https://services.c2d.ch/s3_objects/", s3_object_key),
                          config = httr_config(),
                          httr::write_disk(path = temp_path),
                          times = 5L)
  
  if (use_original_filename) {
    
    final_path <-
      response %>%
      httr::headers() %$%
      `content-disposition` %>%
      stringr::str_extract(pattern = "(?<=filename=\").+?(?=\")") %>%
      fs::path(path, .)
    
  } else {
    final_path <- path
  }
  
  fs::file_move(path = temp_path,
                new_path = final_path)
  
  invisible(response)
}
```

## Validate

This function performs various data validation steps to ensure there are no errors in the database.

WIP

```{r}
validate_referendums <- function(data,
                                 check_sudd_prefix = TRUE) {
  
  if (checkmate::assert_flag(check_sudd_prefix)) {
    
    # define allowed exceptions
    allowed_exceptions <- tibble::tribble(
      ~country_code, ~sudd_prefix,
      # CuraÃ§ao
      "CW", "an",
      # Szeklerland, cf. https://sudd.ch/event.php?id=hu042008
      "RO", "hu"
    )
    
    # assemble target country codes
    country_codes <- data$country_code %>% as.list()
    
    for (country_code in allowed_exceptions$country_code) {
      
      additional_country_codes <- allowed_exceptions %>% dplyr::filter(country_code == !!country_code) %$% sudd_prefix %>% stringr::str_to_upper()
      i_country_codes <- country_codes %>% purrr::map_lgl(~ country_code == .x) %>% which()
      
      for (i in i_country_codes) {
        country_codes[[i]] <- unique(c(country_codes[[i]], additional_country_codes))
      }
    }
    
    # add dummy indicating if target country codes match
    data$matches_sudd_prefix <-
      data$id_sudd %>%
      stringr::str_extract(pattern = "^..") %>%
      stringr::str_to_upper() %>%
      purrr::map2_lgl(.y = country_codes,
                      .f = ~ .x %in% .y)
    
    data$matches_sudd_prefix[is.na(data$id_sudd)] <- NA
  }
  
  data
}
